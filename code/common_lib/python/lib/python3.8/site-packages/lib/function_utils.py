from datetime import datetime
from datetime import timedelta
from datetime import timezone
import pytz
import requests
from boto3.dynamodb.types import TypeDeserializer, TypeSerializer

import dateutil.parser as parser
from lib.dynamo_client import DynamoDbClient
from lib.common_consts import DateTimeConst
from lib.common_utils import get_value_by_key, sort_list
from lib.common_utils import parse_date, parse_time, parse_time_with_sec
from lib.doctor_availability_consts import SlotUpdateType
from lib.graphql_client import GraphqlClient
from lib.entity import Appointment, Patient
from lib.sqs_client import SQSClient
import boto3
import os
import json
import decimal

db_client = DynamoDbClient()
graphql_client = GraphqlClient()
sqsClient = SQSClient()

apiKey = "AIzaSyCzEY7VKqoXdnlj6ThMseRn9dL_W1qLRuY"

def get_datetime(h, m):
    # just set a day
    return datetime(
        year=2020,
        month=12,
        day=3,
        hour=h,
        minute=m)


def get_h_m(dt):
    # dt_split = str(dt).split('.')
    # hours = dt_split[0]
    # mins = dt_split[1] if len(dt_split) == 2 else 0
    # return int(hours), int(mins)
    date_time_obj = datetime.strptime(dt, '%H:%M')
    return int(date_time_obj.hour), int(date_time_obj.minute)


def cal_day_of_week(date, day_index, week_index):
    return date + timedelta(days=-date.weekday() + day_index, weeks=week_index)


def get_day_of_week(date, day, week_index):
    try:
        day_index = get_value_by_key(DateTimeConst.week_day_map, day, 0)
        cal_date = cal_day_of_week(date, day_index, week_index)
        # if cal_date < date:
        #     return cal_day_of_week(date, day_index, week_index + 1)
        return cal_date
    except Exception as e:
        print("get_day_of_week failed", date, day, week_index, e)
        return None


def calculate_slots_per_day(availability):
    try:
        start_time = availability['start_time']
        end_time = availability['end_time']
        time_per_patient_in_minutes = get_value_by_key(availability, 'time_per_patient_in_minutes', 10)
        start_h, start_m = get_h_m(start_time)
        start_date_time = get_datetime(start_h, start_m)

        end_h, end_m = get_h_m(end_time)
        end_date_time = get_datetime(end_h, end_m)

        slots = []
        current_date_time = start_date_time
        current_slots = 1
        while True:
            slot = {
                "slot_number": str(current_slots),
                "start_time": str(current_date_time.time()),
                "availability_group_start_time": start_time,
                "availability_group_end_time": end_time,
            }
            slots.append(slot)
            try:
                current_date_time = current_date_time + timedelta(minutes=time_per_patient_in_minutes)
            except Exception as er:
                print(er)

            current_slots += 1

            if current_date_time >= end_date_time:
                print("exit slots cal current_date_time", current_date_time, "current_slots", current_slots)
                break

        return False, slots, start_time, end_time
    except ValueError as e:
        # invalid data-time range
        return True, e


def get_slot_updates(doctor_id):
    return db_client.doc_availability_slot_update_get(doctor_id)


def check_time_overlapped(pre_slot_start_time, pre_slot_end_time, new_slot_start_time, slot_time_duration):
    slot_time_duration = int(slot_time_duration)
    start_time_1 = parse_time(pre_slot_start_time)
    end_time_1 = parse_time(pre_slot_end_time)

    start_time_2 = parse_time_with_sec(new_slot_start_time)
    end_time_2 = start_time_2 + timedelta(minutes=slot_time_duration)

    # if start_time_1 == start_time_2 or start_time_1 == end_time_2:
    #     return True
    #
    # if end_time_1 == start_time_2 or end_time_1 == end_time_2:
    #     return True

    if start_time_1 < start_time_2 and end_time_1 > end_time_2:
        return True
    elif start_time_1 > start_time_2 and end_time_1 < end_time_2:
        return True
    elif start_time_1 < start_time_2 < end_time_1:
        return True
    elif start_time_1 < end_time_2 < end_time_1:
        return True
    else:
        return False


def update_appointment_status(doctor_id, ap_slot, date, day, week_index, slot_start_time, slot_duration):
    slot_updates = get_slot_updates(doctor_id)
    date = parse_date(date)
    if date is None:
        return

    date_of_day = get_day_of_week(date, day, week_index)
    for slot_update in slot_updates:
        update_type = slot_update['update_type']
        date = slot_update['date']
        cancel_mode = slot_update['cancel_mode']
        start_time = slot_update['start_time']
        end_time = slot_update['end_time']

        if update_type == SlotUpdateType.status_update_type:
            if cancel_mode:
                if day == DateTimeConst.week_day_index_map[parse_date(date).weekday()]:
                    # ap_slot['status'] = AppointmentStatus.AVAILABLE
                    return False
            else:
                if date_of_day == parse_date(date):
                    # ap_slot['status'] = AppointmentStatus.AVAILABLE
                    return False
        else:
            if date_of_day == parse_date(date):
                is_overlapped = check_time_overlapped(start_time, end_time, slot_start_time, slot_duration)
                if is_overlapped:
                    return True
                else:
                    # ap_slot['status'] = AppointmentStatus.AVAILABLE
                    return False
                    # if false slot not will add to return list
                    # return False
    return True


# available_today, updated_slots_found, updated_slots
def check_today_availability(doctor_id, date, day, week_index, slot_duration):
    available_today = True
    updated_slots_found = False
    updated_slots = []
    slot_updates = get_slot_updates(doctor_id)
    date = parse_date(date)
    if date is None:
        return available_today, updated_slots_found, updated_slots

    date_of_day = get_day_of_week(date, day, week_index)
    for slot_update in slot_updates:
        update_type = slot_update['update_type']
        date = slot_update['date']
        cancel_mode = slot_update['cancel_mode']
        start_time = slot_update['start_time']
        end_time = slot_update['end_time']

        if update_type == SlotUpdateType.status_update_type:
            if cancel_mode:
                if day == DateTimeConst.week_day_index_map[parse_date(date).weekday()]:
                    updated_slots_found = True
                    available_today = False
            else:
                if date_of_day == parse_date(date):
                    updated_slots_found = True
                    available_today = False
        else:
            if date_of_day == parse_date(date):
                is_fail, cal_slots, start_time, end_time = calculate_slots_per_day({
                    "start_time": start_time,
                    "end_time": end_time,
                    "time_per_patient_in_minutes": float(slot_duration),
                })
                updated_slots_found = not is_fail
                updated_slots = cal_slots
    return available_today, updated_slots_found, updated_slots


def update_slots_if_not_exists(saved_doctor_dispensary, new_slots):
    saved_slots = get_value_by_key(saved_doctor_dispensary, 'slots')
    if (saved_slots is None) or (len(saved_slots) == 0):
        return new_slots

    # convert to keys
    saved_slots_dic = {}
    for saved_slot in saved_slots:
        saved_slots_dic[saved_slot['day']] = saved_slot

    # convert to keys
    new_slots_dic = {}
    for new_slot in new_slots:
        new_slots_dic[new_slot['day']] = new_slot

    slots = []
    for day, _ in list(DateTimeConst.week_day_map.items()):

        slot_by_new_slots = get_value_by_key(new_slots_dic, day)
        slot_by_saved_slots = get_value_by_key(saved_slots_dic, day)

        if slot_by_new_slots is not None:
            slots.append(slot_by_new_slots)
        elif slot_by_saved_slots is not None:
            slots.append(slot_by_saved_slots)

    return slots


def iso_time(text):
    date = parser.parse(text)
    return date.isoformat()


def get_availability_time_frame(disp_doc, day, today_date):
    availability_groups = get_value_by_key(disp_doc, 'availability_groups')
    if not availability_groups:
        print("availability_groups are empty")
        return False, None, None

    availability_groups = get_value_by_key(availability_groups, day)
    if not availability_groups:
        print("availability_groups per day are empty", day)
        return False, None, None

    # availability_end_dates_map = get_value_by_key(disp_doc, 'availability_end_dates_map')
    # if availability_end_dates_map is not None:
    #     day_end_date = get_value_by_key(availability_end_dates_map, day)
    #     if day_end_date is not None:
    #         day_end_date = parse_date(day_end_date)
    #         if today_date != day_end_date:
    #             print("availability is end for this day : ", day, ", date : ", today_date)
    #             return False, None, None

    doctor_id = str(disp_doc['PK']).replace('doctor#', '')
    dispensary_id = str(disp_doc['SK']).replace('dispensary#', '')
    time_period = db_client.get_doctor_dispensary_availability_time_period(doctor_id, dispensary_id, day)
    if not time_period:
        return False, None, None
    time_period = time_period[0]
    start_data = parse_date(time_period['start_date'])
    end_date = get_value_by_key(time_period, 'end_date')

    if end_date is None:
        if not (start_data <= today_date):
            return False, None, None
    else:
        end_date = parse_date(end_date)
        if not (start_data <= today_date <= end_date):
            return False, None, None

    availability_groups = sort_list(availability_groups, _key=lambda i: parse_time(i['start_time']))
    availability_group_first = availability_groups[0]
    availability_group_last = availability_groups[len(availability_groups) - 1]

    start_time = parse_time(get_value_by_key(availability_group_first, 'start_time'))
    end_time = parse_time(get_value_by_key(availability_group_last, 'end_time'))

    return True, start_time, end_time


def extract_date_str(dt):
    return str(dt).split(" ")[0]


def update_slot(date_of_day, day, pre_slot, slot_updates):
    for slot_update in slot_updates:
        update_type = slot_update['update_type']
        date = slot_update['date']
        cancel_mode = slot_update['cancel_mode']
        start_time = slot_update['start_time']
        end_time = slot_update['end_time']

        if update_type == SlotUpdateType.status_update_type:
            if cancel_mode:
                c_date = parse_date(date)
                if (day == DateTimeConst.week_day_index_map[c_date.weekday()]) and (date_of_day >= c_date):
                    pre_slot['available'] = False
            else:
                if date_of_day == parse_date(date):
                    pre_slot['available'] = False
        else:
            if date_of_day == parse_date(date):
                p_start_time = parse_time(start_time)
                p_end_time = parse_time(end_time)
                pre_slot['start_time'] = iso_time(
                    str(date_of_day.replace(hour=p_start_time.hour, minute=p_start_time.minute)))
                pre_slot['end_time'] = iso_time(
                    str(date_of_day.replace(hour=p_end_time.hour, minute=p_end_time.minute)))


def get_availabilities(doctor_id, doctor, disp_doc, date, week_index):
    date = parse_date(date)
    if date is None:
        return []

    # availability_start_date = parse_date(get_value_by_key(disp_doc, 'availability_start_date'))
    # availability_end_date = parse_date(get_value_by_key(disp_doc, 'availability_end_date'))
    #
    # if availability_start_date is None:
    #     print("unable to found availability_start_date or availability_start_date for ", disp_doc)
    #     return []
    #
    # if availability_end_date is None:
    #     availability_enable = availability_start_date <= date
    # else:
    #     availability_enable = availability_start_date <= date <= availability_end_date
    #
    # if not availability_enable:
    #     print("unable to found availability withing start, end, request_date"
    #           , availability_start_date, availability_end_date, date)
    #     return []

    slots = get_value_by_key(disp_doc, 'slots', [])
    if not slots:
        print("unable to found any slots")
        return []

    slot_updates = get_slot_updates(doctor_id)

    availabilities = []
    for slot in slots:
        day = slot['day']
        available = True  # TODO
        date_of_day = get_day_of_week(date, day, week_index)

        avi_status, start_time, end_time = get_availability_time_frame(disp_doc, day, date_of_day)
        if not avi_status:
            print("failed to get availability_time_frame", day)
            continue

        # start time
        start_time_s = iso_time(str(date_of_day.replace(hour=start_time.hour, minute=start_time.minute)))

        # end time
        end_time_s = iso_time(str(date_of_day.replace(hour=end_time.hour, minute=end_time.minute)))

        prep_slot = {
            "available": available,
            "day": day,
            "date": extract_date_str(date_of_day),
            "start_time": start_time_s,
            "end_time": end_time_s
        }
        update_slot(date_of_day, day, prep_slot, slot_updates)
        availabilities.append(prep_slot)

    availabilities = sort_list(availabilities, _key=lambda i: parse_date(i['date']))
    return availabilities


def get_doctor_delay(doctor_id, date):
    response = db_client.get_doctor_delay_by_doctor_and_date(doctor_id, date)
    if not response:
        return 0
    else:
        return get_value_by_key(response[0], 'hours', 0)


def get_open_slot(doctor, doctor_id, date, availabilities):
    day = DateTimeConst.week_day_index_map[parse_date(date).weekday()]
    for av in availabilities:
        if av['day'] == day and av['available'] == True:
            selected_slot = {
                'slot_id': '1',
                'slot_time': av['start_time'],
                'delay': {
                    'minute': get_doctor_delay(doctor_id, date)
                },
                'available': av['available']
            }
            doctor['open_slot'] = selected_slot
            return

    doctor['open_slot'] = None


class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return str(o)
        return super(DecimalEncoder, self).default(o)


def get_previous_visits(patient_id, doctor):
    visits = db_client.get_patient_doctor_visits(patient_id)
    if not visits:
        return []

    visits = sort_list(visits, _key=lambda i: parse_date(i['date']))
    r = 1
    prep_visits = []
    for v in visits:
        vi = {
            "visit_number": r,
            "doctor": {
                "display_name": get_value_by_key(doctor, "display_name", "")
            },
            "date": get_value_by_key(v, "date", ""),
            "note": get_value_by_key(v, "note", "")
        }

        r = r + 1
        prep_visits.append(vi)

    return prep_visits


def notify_users(doctor_id, dispensary_id, patient_id, day, date, appointment, *, cancel_appointment=False):
    if cancel_appointment:
        json_dump = json.dumps(appointment, cls=DecimalEncoder)
        appointment = json.loads(json_dump)
        request = {
            "doctor_id": doctor_id,
            "dispensary_id": dispensary_id,
            "day": day,
            "date": date,
            "slot": {
                "slot_id": appointment['slot_id'],
                "status": appointment['status'],
                "slot_time": appointment['slot_time']
            }
        }
        graphql_client.call_appointment_update_mutation(request)
    else:

        # for a in appointments:
        a_json = json.dumps(appointment, cls=DecimalEncoder)
        appointment = Appointment.json_load(json.loads(a_json))
        request = {
            "doctor_id": doctor_id,
            "dispensary_id": dispensary_id,
            "day": day,
            "date": date,
            "slot": {
                "slot_id": appointment.slot_id,
                "status": appointment.status,
                "slot_time": appointment.slot_time,
                "symptom": appointment.symptom,
                "note": appointment.note,
                "patient": appointment.patient,
                "previous_visits": get_previous_visits(patient_id, doctor_id),
                "kiosk": appointment.kiosk,
                "booking_method": appointment.booking_method,
                "vital_signs":appointment.vital_signs
            }
        }
        graphql_client.call_appointment_update_mutation(request)


def push_sms_notification(message):
    sqsClient.publish_sms_notification(json.dumps(message))


def next_available_slots(doctor_id, date, day, week_index, saved_doctor_dispensary, isKiosk=False):
    appointments = db_client.get_appointments_by_doctor_and_date(doctor_id, date)
    json_dump = json.dumps(appointments, cls=DecimalEncoder)
    appointments = json.loads(json_dump)
    filtered_appointment = list(filter(lambda x: not x['cancel'], appointments))
    slots = []
    available_today, updated_slots_found, updated_slots = \
        check_today_availability(doctor_id, date, day, week_index,
                                 get_value_by_key(saved_doctor_dispensary, "slot_duration"))
    if updated_slots_found:
        slots = updated_slots
    else:
        d_slots = get_value_by_key(saved_doctor_dispensary, 'slots', [])
        for s in d_slots:
            # print(s)
            if day == s['day']:
                slots = s['slots']
                break

    if not slots:
        print("unable to found any slots for given day")
    booked_slot_id = list(map(lambda x: x['slot_id'], filtered_appointment))
    last_booked_slot = []
    appointment_time_in_minutes = 0
    if isKiosk:
        # print(">>> slot inside kiosk ::: ", slots)
        ist_time = pytz.timezone('Asia/Colombo')
        now = datetime.now(ist_time)
        current_datetime = now.strftime('%Y-%m-%d %H:%M:%S')
        # print(">>> current datetime ::: ", current_datetime)

        current_date = now.strftime('%Y-%m-%d')
        # print(">>> current date ::: ", current_date)
        # print(">>> available group start time ::: ",
        #       current_date + " " + slots[0]['availability_group_start_time'] + ':00')
        start_datetime = current_date + " " + slots[0]['availability_group_start_time'] + ':00'
        # print(">>> Differentce c s ::: ", datetime.strptime(current_datetime, '%y-%m-%d %H:%M:%S') - datetime.strptime(start_datetime, '%y-%m-%d %H:%M:%S'))
        # print(">>> Differentce s c::: ", datetime.strptime(start_datetime,'%y-%m-%d %H:%M:%S') - datetime.strptime(current_datetime, '%y-%m-%d %H:%M:%S'))
        if(datetime.strptime(current_datetime, '%Y-%m-%d %H:%M:%S') < datetime.strptime(start_datetime, '%Y-%m-%d %H:%M:%S')):
            print("early session")
            print(">>> filtered appointment ::: ", filtered_appointment)
            print(">>> slots ::: ", slots)
            print(">>> not in booked slots ::: ", list(filter(lambda x: x['slot_number'] not in booked_slot_id, slots)))
            early_filtered_appointment = list(filter(lambda x: datetime.strptime(x['slot_time'], '%Y-%m-%d %H:%M:%S') < datetime.strptime(start_datetime, '%Y-%m-%d %H:%M:%S'), filtered_appointment))
            print(">>> early filterd appointments ::: ", early_filtered_appointment)
            curr_slot_number = len(early_filtered_appointment)
            last_booked_slot = slots[-1]
            last_booked_slot['start_time'] = current_datetime
            last_booked_slot['slot_number'] = curr_slot_number
            # second_last_slot_time = filtered_appointment[-2]['slot_time']
            # first_last_slot_time = filtered_appointment[-1]['slot_time']
            # time_delta = datetime.strptime(first_last_slot_time, '%Y-%m-%d %H:%M:%S') - datetime.strptime(
            #     second_last_slot_time, '%Y-%m-%d %H:%M:%S')
            appointment_time_in_minutes = 2
            print(">>> last booked slot ::: ", last_booked_slot)
            return [], last_booked_slot, appointment_time_in_minutes
            # return [{'start_time': now.strftime('%H:%M:%S'), 'availability_group_start_time': '01:00', 'availability_group_end_time': slots[0]['availability_group_start_time'], 'slot_number': curr_slot_number}]
        else:
            print("normal session")
            filtered_appointment = list(filter(lambda x: datetime.strptime(x['slot_time'], '%Y-%m-%d %H:%M:%S') >= datetime.strptime(start_datetime,'%Y-%m-%d %H:%M:%S'), filtered_appointment))
            print(">>> filtered appointment else ::: ", filtered_appointment)
            if len(filtered_appointment) >= len(slots):
                filtered_appointment.sort(key=lambda x: x['slot_time'])
                last_booked_slot = slots[-1]
                last_booked_slot['start_time'] = filtered_appointment[-1]['slot_time']
                last_booked_slot['slot_number'] = filtered_appointment[-1]['slot_id']
                second_last_slot_time = filtered_appointment[-2]['slot_time']
                first_last_slot_time = filtered_appointment[-1]['slot_time']
                time_delta = datetime.strptime(first_last_slot_time, '%Y-%m-%d %H:%M:%S') - datetime.strptime(
                    second_last_slot_time, '%Y-%m-%d %H:%M:%S')
                appointment_time_in_minutes = time_delta.total_seconds() / 60
            filtered_appointment = list(filter(lambda x: datetime.strptime(x['slot_time'], '%Y-%m-%d %H:%M:%S') >= datetime.strptime(start_datetime,'%Y-%m-%d %H:%M:%S'),filtered_appointment))
            booked_slot_id = list(map(lambda x: x['slot_id'], filtered_appointment))
            return list(filter(lambda x: x['slot_number'] not in booked_slot_id,
                               slots)), last_booked_slot, appointment_time_in_minutes
    else:
        return list(filter(lambda x: x['slot_number'] not in booked_slot_id, slots))


def push_notification(user_id, message, title):
    users = db_client.get_notification_tokens(user_id)
    print(users)
    for user in users:
        request = {"token": user['PK'],
                   "service": user['platform'],
                   "message": message,
                   "title": title
                   }
        print(request)
        response = sqsClient.publish_push_notification(json.dumps(request))
        print(response)

def get_destination_by_geo_points(geo_point, response):
    json_dump = json.dumps(response, cls=DecimalEncoder)
    results = json.loads(json_dump)
    latd, lond = results['geo_location']['lat'], results['geo_location']['lon']
    lato, lono = geo_point['lat'], geo_point['lon']

    destination_str = "{} {}".format(latd, lond)
    origin_str = "{} {}".format(lato, lono)
    url1 = "https://maps.googleapis.com/maps/api/distancematrix/json?origins="
    origin = origin_str
    url2 = "&destinations="
    destination = destination_str
    url3 = "&key="
    full_url = url1 + origin + url2 + destination + url3 + apiKey

    responses = requests.get(full_url).json()
    return responses