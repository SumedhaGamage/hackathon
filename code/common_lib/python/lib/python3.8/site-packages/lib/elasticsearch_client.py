import os
import json
import urllib3
import uuid

from docutils.nodes import citation

els_index = 'app'
els_document_type = '_doc'
document_id_field = 'mobile_number'
document_sub_field = 'dispensary'

class ElasticSearchClient:
    def __init__(self):
        '''create elasticsearch client'''
        self.host = os.environ.get('ELASTIC_SEARCH_HOST')
        self.api_key = os.environ.get('ELASTIC_SEARCH_AUTH')
        self.api = "{}/{}/{}".format(self.host, els_index, els_document_type)

        self.http_client = urllib3.PoolManager()
        self.create_geo_point_index()

    def save(self, id, data):
        url = "{}/{}".format(self.api, id)
        encoded_data = json.dumps(data).encode('utf-8')
        response = self.http_client.request(
            'PUT',
            url,
            body=encoded_data,
            headers={
                'Content-Type': 'application/json'
                , 'Authorization': self.api_key
            }
        )
        if response.status == 200 or response.status == 201:
            return True, response.data
        else:
            return False, response.data

    def get_by_id(self, id):
        url = "{}/{}".format(self.api, id)
        response = self.http_client.request('GET', url, headers={
                'Content-Type': 'application/json'
                , 'Authorization': self.api_key
            })
        if response.status == 200:
            return True, json.loads(response.data.decode('utf-8'))['_source']
        else:
            return False, response.data

    def search(self, query):
        url = "{}/_search".format(self.api)
        encoded_data = json.dumps(query).encode('utf-8')
        response = self.http_client.request(
            'GET'
            , url
            , body=encoded_data
            , headers={
                'Content-Type': 'application/json'
                , 'Authorization': self.api_key
            }
        )
        if response.status == 200:
            return True, json.loads(response.data.decode('utf-8'))['hits']['hits']
        else:
            return False, response.data

    def doctor_save(self, doctor):
        id = doctor[document_id_field]
        status, match_doctors = self.doctor_search_by_id(id)
        if not status:
            return status, "els.doctor_search_by_id {}".format(match_doctors)

        if not match_doctors:
            # save new doctor
            els_id = str(uuid.uuid1())
            return self.save(els_id, doctor)
        else:
            # save already exists doctor
            updated_doctors = []
            for match_doctor in match_doctors:
                els_id = match_doctor['_id']
                match_doctor = match_doctor['_source']
                if document_sub_field in match_doctor:
                    dispensary = match_doctor[document_sub_field]
                    doctor[document_sub_field] = dispensary
                    self.save(els_id, doctor)
                updated_doctors.append({'id': els_id, 'data': doctor})

            # TODO bulk update : updated_doctors
            return True, True

    def doctor_add_dispensary(self, doctor_id, dispensary):
        status, match_doctors = self.doctor_search_by_id(doctor_id)
        if not status:
            return status, "els.doctor_search_by_id {}".format(match_doctors)

        if not match_doctors:
            return False, 'Doctor not found'
        elif (len(match_doctors) == 1) and (document_sub_field not in match_doctors[0]['_source']):
            # found only one saved doctor and not associate with a dispensary
            els_id = match_doctors[0]['_id']
            match_doctor = match_doctors[0]['_source']
            match_doctor[document_sub_field] = dispensary
            return self.save(els_id, match_doctor)
        else:
            els_id = str(uuid.uuid1())
            doctor = match_doctors[0]['_source']
            doctor[document_sub_field] = dispensary
            return self.save(els_id, doctor)

    def doctor_search_by_id(self, id):
        query = {
          "query": {
            "match": {
              document_id_field: id
            }
          }
        }
        return self.search(query)

    def doctor_search_by_name_prefix_and_geo_distance(self, name_prefix, geo_point, distance, specialty, city):
        distance = str(distance) + "km"

        must = []
        filter = []
        sort = []
        if name_prefix is not None and name_prefix != "":
            must.append({
                    "multi_match": {
                        "query": name_prefix,
                        "type": "bool_prefix",
                        "fields": [
                            "first_name",
                            "last_name"
                        ]
                    }
                })

        if geo_point is not None:
            filter.append({
                "geo_distance": {
                    "distance": distance,
                    "dispensary.geo_location": geo_point
                }
            })
            sort.append({
                "_geo_distance": {
                    "dispensary.geo_location": geo_point,
                    "order": "asc",
                    "unit": "km"
                }
            })

        if specialty is not None and specialty != "":
            must.append({
                    "match_bool_prefix": {
                        "specialty": specialty
                    }
                })

        if city is not None and city != "":
            must.append({
                    "match_bool_prefix": {
                        "dispensary.address": city
                    }
                })

        query = {
            "query": {
                "bool": {
                    "must": must,
                    "filter": filter
                }
            },
            "sort": sort
        }
        return self.search(query)

    def ___doctor_search_by_name_prefix_and_geo_distance(self, name_prefix, geo_point, distance):
        distance = str(distance) + "km"
        if not name_prefix:
            query = {
                "query": {
                    "bool": {
                        "must": {
                            "match_all": {}
                        },
                        "filter": {
                            "geo_distance": {
                                "distance": distance,
                                "dispensary.geo_location": geo_point
                            }
                        }
                    }
                },
                "sort": [
                    {
                        "_geo_distance": {
                            "dispensary.geo_location": geo_point,
                            "order": "asc",
                            "unit": "km"
                        }
                    }
                ]
            }
        elif not geo_point:
            query = {
                "query": {
                    "bool": {
                        "must": {
                            "match_bool_prefix": {
                                "first_name": name_prefix
                            }
                        }
                    }
                }
            }
        else:
            query = {
                "query": {
                    "bool": {
                        "must": {
                            "match_bool_prefix": {
                                "first_name": name_prefix
                            }
                        },
                        "filter": {
                            "geo_distance": {
                                "distance": distance,
                                "dispensary.geo_location": geo_point
                            }
                        }
                    }
                },
                "sort": [
                    {
                        "_geo_distance": {
                            "dispensary.geo_location": geo_point,
                            "order": "asc",
                            "unit": "km"
                        }
                    }
                ]
            }

        dispensary_key = 'dispensary'
        dispensaries_key = 'dispensaries'
        status, response = self.search(query)
        if not status:
            return status, "els.search {}".format(response)
        unique_doctors = {}
        for r in response:
            doctor = r['_source']
            id = doctor[document_id_field]
            doctor['id'] = id
            dispensary = doctor[document_sub_field]

            # TODO need to set distance by geo
            dispensary['distance'] = 1.5

            if id in unique_doctors:
                dispensaries = unique_doctors[id][dispensaries_key]
                dispensaries.append(dispensary)
            else:
                unique_doctors[id] = doctor
                unique_doctors[id][dispensaries_key] = []
                if (document_sub_field in doctor) and (dispensary is not None):
                    unique_doctors[id][dispensaries_key].append(dispensary)

            if dispensary_key not in unique_doctors[id]:
                unique_doctors[id][dispensary_key] = dispensary

        return True, list(unique_doctors.values())

    def delete(self, index, id):
        pass

    def create_geo_point_index(self):
        data = {
            "mappings": {
                "properties": {
                    "dispensary": {
                        "properties": {
                            "geo_location": {
                                "type": "geo_point"
                            }

                        }

                    }
                }
            }
        }
        url = "{}/{}".format(self.host, els_index)
        encoded_data = json.dumps(data).encode('utf-8')
        response = self.http_client.request(
            'PUT',
            url,
            body=encoded_data,
            headers={
                'Content-Type': 'application/json'
                , 'Authorization': self.api_key
            }
        )
        if response.status == 200 or response.status == 201:
            return True, response.data
        else:
            return False, response.data